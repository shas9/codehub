/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}
/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <set>
#include <sstream>

using namespace std;

#define oo 0x7F7F7F7F
#define LET(x,a)     __typeof(a) x(a)
#define EACH(it,v)   for(LET(it,v.begin());it!=v.end();++it)
#define REP(i,n)     for(__typeof(n) i(0); i<n; i++)
#define ALL(x)       (x).begin(), (x).end()
#define gint(t)      t = readUInt();
#define pint(t)      printf("%d\n", t);
#define pb           push_back
#define mp           make_pair
#ifdef JAI_ARENA
#define debug(args...) {cerr<<"> "; dbg,args;cerr<<endl;}
#define debugv(v)      {cerr<<"> "; EACH(it, v) dbg,(*it); cerr<<endl;}
#else
#define debug(args...) {}
#define debugv(x) {}
#endif
typedef long long int   ll;
typedef unsigned long long int ull;
typedef unsigned int    uint;
typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
    {
        cerr<<v<<" ";
        return *this;
    }
} dbg;


#define BUF 40960000
char ibuf[BUF];
int ipt = BUF;
 
int readUInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0; 
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
    fread(ibuf, 1, BUF, stdin);
    ipt = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
int testcase;
int inv[4][40];
inline int gpc(int n, const int m) {
    int p = 0;
    while(n) {
        n/=m;
        p+=n;
    }
    return p;
}
inline int power(const int x, unsigned n, const int m) {
    int intermediateProduct = x;
    int result = 1;
    while(n)
    {
        if (n & 1)
            result = (intermediateProduct * result)%m;
        n >>= 1;
        intermediateProduct = (intermediateProduct * intermediateProduct)%m;
    }
    return result;
}
inline int inverse(const int n, const int m) {
    switch(m) {
        case 11:
            return inv[0][n];
        case 13:
            return inv[1][n];
        case 27:
            return inv[2][n];
        case 37:
            return inv[3][n];
    }
    return 0;
}
inline int get_p(int st, int end, int m, int p) {
    int prodp = 1;
    for(int i = 1; i<m; i++) {
        if(i%p == 0) continue;
        prodp *= (i%m);
        prodp %= m;
        //debug(m, p, i, prodp)
    }
    int prod = 1;
    while(st<=end) {
        if(st%m==0) {
            int rounds = (end-st+1)/m;
            prod *= power(prodp, rounds, m);
            prod %=m;
            st+=rounds*m;
            st++;
            continue;
        }
        if(st%p == 0) {st++; continue;}
        prod = (prod*(st%m))%m;
        st++;
    }
    //debug("get_p", prod, prodp);
    return prod;
}
inline int get_product(int st, int l, int m, int p) {
    int prod = 1;
    while(st<=l) {
        prod*=get_p(st, l, m, p);
        prod %= m;
        int st2 = st/p;
        if(st2*p<st) st2++;
        st = st2;
        l/=p;
    }
    return prod;
}
inline int gncr(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, m)-gpc(r, m)-gpc(n-r, m);
    if(p>0) { return 0;}
    int num   = get_product(n-r+1, n, m, m);
    int denom = get_product(1, r, m, m);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, m), get_product(1, r, m, m));
    return (num*inverse(denom, m))%m;
}
inline int gncr27(int n, int r, int m) {
    if(r>n-r) r = n-r;
    int p = gpc(n, 3)-gpc(r, 3)-gpc(n-r, 3);
    if(p>=3) return 0;
    int nst = n-r+1, nl = n;
    int dst = 1, dl = r;
    int num   = get_product(nst, nl, m, 3);
    int denom = get_product(dst, dl, m, 3);
    //debug(n, r, m, num, denom, get_product(n-r+1, n, m, 3), get_product(1, r, m, 3));
    int res = (num*inverse(denom, m))%m;
    while(p) {
        res = (res*3)%m;
        p--;
    }
    return res;
}
int mul, b11, b13, b27, b37;
int m11, m13, m27, m37;
inline int solve_crt(int n11, int n13, int n27, int n37) {
    return ((n11*b11*m11) + (n13*b13*m13) + (n27*b27*m27) + (n37*b37*m37))%mul;
}
void solve() {
    int n, r; gint(n); gint(r);
    int ncr11 = gncr(n, r, 11);
    int ncr13 = gncr(n, r, 13);
    int ncr27 = gncr27(n, r, 27);
    int ncr37 = gncr(n, r, 37);
    //debug(ncr11, ncr13, ncr27, ncr37);
    printf("%d\n", solve_crt(ncr11, ncr13, ncr27, ncr37));
}
bool input() {
    return true;
}
void preprocess() {
    int nums[] = {11, 13, 27, 37};
    for(int  i = 0; i<4; i++) {
        if(i==2) continue;
        int p = nums[i];
        for(int j=1; j<p; ++j) {
            inv[i][j] = power(j, p-2, p);
            //debug(j, p, inv[i][j]);
        }
    }
    for(int i = 1; i<27; i++) {
        if(i%3==0) continue;
        int j = 1;
        for(; j<27; j++)  {
            if((i*j)%27==1) {
                break;
            }
        }
        inv[2][i] = j;
    }
    mul = 11*13*27*37;
    m11 = mul/11;
    m13 = mul/13;
    m27 = mul/27;
    m37 = mul/37;
    b11 = inv[0][m11%11];
    b13 = inv[1][m13%13];
    b27 = inv[2][m27%27];
    b37 = inv[3][m37%37];
    
}
int main()
{
    preprocess();
    //cout<<get_product(1, 5, 27, 3)<<endl;
    gint(testcase);
    while(testcase--)
        if(input())
                solve();
    return 0;
}